import { RawFeed, ScanResult } from '@/domain/scan-result';
import { SourceConfiguration, Source } from '@/domain/source-config';
import { ReportGenerator, ReportGenerationItem } from '@/infrastructure/report-generator';
import { SourceFetcher } from '@/infrastructure/source-fetcher';
import { logger } from '@/utils/logger';

export class ScanService {
    constructor(
        private config: SourceConfiguration,
        private sourceFetcher: SourceFetcher,
        private reportGenerator: ReportGenerator,
    ) {}

    async performScan(): Promise<ScanResult> {
        logger.info('Starting daily scan', {
            timezone: this.config.scan_config.timezone,
            topicCount: this.config.topics.length,
        });

        const scanDate = new Date().toISOString().split('T')[0];
        const generationItems: ReportGenerationItem[] = [];

        // Fetch all sources from all topics
        for (const topic of this.config.topics) {
            logger.info('Processing topic', { topic: topic.name, sourceCount: topic.sources.length });

            for (const source of topic.sources) {
                try {
                    const feeds = await this.sourceFetcher.fetchSource(
                        source,
                        this.config.scan_config.lookback_hours,
                    );

                    generationItems.push(
                        ...feeds.map((feed) =>
                            this.buildGenerationItem(
                                feed,
                                topic.category,
                                topic.name,
                                topic.priority,
                                source,
                            ),
                        ),
                    );

                    logger.info('Source fetched', { source: source.name, itemCount: feeds.length });
                } catch (error) {
                    logger.error('Error fetching source', { source: source.name, error });
                    // Continue with other sources
                }
            }
        }

        logger.info('All sources fetched, sending to ChatGPT for analysis', {
            totalItems: generationItems.length,
        });

        // Send everything to ChatGPT - it will analyze and return the structured JSON
        const report = await this.reportGenerator.generateReport({
            date: scanDate,
            timezone: this.config.scan_config.timezone,
            items: generationItems,
        });

        logger.info('Report generated by ChatGPT', {
            topSignals: report.top_signals?.length ?? 0,
            securityAlerts: report.security_alerts?.length ?? 0,
            awsChanges: report.aws_platform_changes?.length ?? 0,
            aiTrends: report.ai_trends?.length ?? 0,
        });

        return report;
    }

    private buildGenerationItem(
        feed: RawFeed,
        category: string,
        topicName: string,
        priority: number,
        source: Source,
    ): ReportGenerationItem {
        return {
            title: feed.title,
            source: feed.source,
            source_url: feed.source_url,
            published_at: feed.published_at,
            topic: topicName,
            category,
            priority,
            source_type: source.type,
        };
    }
}
